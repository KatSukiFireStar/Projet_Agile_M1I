<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: main.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: main.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Classe Adaptateur qui permet d'adapter les données en fonction de nos besoins
 * En entrée, on aura toutes les données "en vrac" et en sortie, on aura les données prêtes à l'envoi en fonction des
 * besoins que l'on aura dans la page de jeux
 */
class Adaptateur {
    /**
     * Constructeur de la classe Adaptateur
     * @param {0 | 1} option - Type de partie à lancer (0 pour une nouvelle partie | 1 pour reprendre une partie)
     */
    constructor(option) {
        if (option === 0) {
            this.adapterNouvellePartie();
        } else if (option === 1) {
            this.adapterAnciennePartie();
        }
    }
    
    /** Méthode qui permet de préparer les données dans le cas d'une partie que l'on veut reprendre
     * asynchrone, car elle attend le chargement du fichier json que l'on récupère.
     * récupère uniquement la position de la tache sur laquelle on s'était arrêté.
     */
    async adapterAnciennePartie() {
        try{
            const position = await this.recupererSituation();
            this.donnees = {
                indice: position,
                fichierJson: get('jsonFileReprendre').value
            };
            const envoie = JSON.stringify(this.donnees);
            window.location.href = "./jeux.html?data=" + encodeURIComponent(envoie);
        } catch (e) {
            console.log("erreur : ", e);
        }
    }

    /**
     * Méthode qui récupère la position de la dernière tâche traitée
     * @returns {Promise&lt;unknown>} - promesse (asychrone) qui contient l'indice de la dernière tâche traitée
     */
    async recupererSituation() {
        return new Promise((resolve, reject) => {
            let base = get('jsonFileReprendre');

            if (base.files.length > 0) {
                let fichier = base.files[0];
                let position = 0;
                let lecteur = new FileReader();

                lecteur.onload = function (evt) {
                    let fichierJson = JSON.parse(evt.target.result);
                    let liste = fichierJson["liste_tache"];

                    for(let i=0; i&lt;liste.length; i++) {
                        let maTache = fichierJson["liste_tache"][i];
                        if (maTache['difficulte'] !== "") {
                            position += 1;
                        }
                    }

                    resolve({ position });
                };

                lecteur.onerror = function (evt) {
                    reject("Erreur lors de la lecture du fichier");
                };

                lecteur.readAsText(fichier);
            } else {
                console.log("Aucun fichier sélectionné");
                reject("Aucun fichier sélectionné");
            }
        });
    }

    /** Méthode qui s'occupe d'adapter les données dans le cas où l'on lance une nouvelle partie
     * s'occupe aussi d'envoyer les données vers la page de jeux*/
     adapterNouvellePartie() {
        let base = get('jsonFileLancer');
        if (base.files.length > 0) {
            let fichier = base.files[0];
            let position = 0;
            let lecteur = new FileReader();

            lecteur.onload = function (evt) {
                let fichierJson = JSON.parse(evt.target.result);
                saveData("fichier", JSON.stringify(fichierJson));
            };

            lecteur.onerror = function (evt) {
                reject("Erreur lors de la lecture du fichier");
            };

            lecteur.readAsText(fichier);
        } else {
            console.log("Aucun fichier sélectionné");
            reject("Aucun fichier sélectionné");
        }

        this.donnees = {
            mode: this.adapterMode(),
            nbJoueurs: this.adapterNbJoueurs(),
            nomJoueurs: this.adapterListeJoueurs(),
            fichierJson: get('jsonFileLancer').value.substring(12)
        };

        const envoie = JSON.stringify(this.donnees);
        window.location.href = "./jeux.html?data=" + encodeURIComponent(envoie);
    }

    /**
     * Méthode qui adapte le mode de jeux dans le cas d'une nouvelle partie
     * @returns {*|string} - le mode de jeux sélectionné ou celui par défaut (strict)
     */
    adapterMode() {
        let mode = _('input[name="mode"]:checked').value;
        // On vérifie que le mode est bien correct 
        if ((mode === Modes.Strict) || (mode === Modes.Moyenne)) {
            return mode;
        }
        return Modes.Strict;
    }

    /**
     *  Méthode qui adapte le nombre de joueurs dans le cas d'une nouvelle partie
     * @returns {number|*} - le nombre de joueurs choisi ou celui par défaut (3)
     */
    adapterNbJoueurs() {
        let nbJoueurs = _('input[name="nbJoueurs"]:checked').value;
        if (1 &lt; nbJoueurs &amp;&amp; nbJoueurs &lt; 5) {
            return nbJoueurs;
        }
        return 3;
    }

    /**
     * Méthode qui adapte le nombre de joueurs dans le cas d'une nouvelle partie
     * @returns {string[]}
     */
    adapterListeJoueurs() {
        let listeJoueurs = [];
        let tab = document.querySelectorAll('input[name=\"nomJoueurs\"]');
        
        for (let i = 0; i &lt; tab.length; i++) {
            listeJoueurs.push(tab[i].value);
        }

        if (listeJoueurs.length !== 0) {
           return listeJoueurs;
        }
        return ['Pedro', 'Sancho', 'Mendoza'];
    }
}

/** Fonction qui s'active quand on clique sur le bouton (i) 
 * Cette fonction va afficher les règles si les règles étaient masquées et va les masquer dans le cas contraire*/ 
function afficherRegles() {
    let regles = get('regles-overlay');
    regles.style.display = (regles.style.display === 'block') ? 'none' : 'block';
}

/** Fonction qui va masquer les règles du jeu */
function masquerRegles() {
    let regles = get('regles-overlay');
    regles.style.display = 'none';
}

/** Fonction qui va afficher/masquer les menus de jeu, procède aux nettoyages,
 * bon affichage dans le cas du menu pour une nouvelle partie
 * @param {0 | 1} option - Type de partie à lancer (0 pour une nouvelle partie | 1 pour reprendre une partie)
*/
function afficherMenu(option) {
    if(option !== 0 &amp;&amp; option !== 1){
        console.error("Vous tentez de valider un formulaire avec de mauvais parametres!");
        return;
    }

    const menuLancer = get('0');
    const menuReprendre = get('1');
    
    if (option === 0) {
        nettoyerMenu(get('1'));
        menuLancer.style.display = 'flex';
        menuReprendre.style.display = 'none';
        afficherJoueur(2);
    } else if (option === 1) {
        nettoyerMenu(get('0'));
        menuReprendre.style.display = 'flex';
        menuLancer.style.display = 'none';
    }
}

/** Fonction qui va afficher l'intitulé des règles 
 * en fonction du bouton sur lequel l'utilisateur a cliqué 
*/
function afficherRegleMode(option){
    if(option !== 0 &amp;&amp; option !== 1){
        console.error("Vous tentez de valider un formulaire avec de mauvais parametres!");
        return;
    }

    let regleStrict = get("regleStrict");
    let regleMoyenne = get("regleMoyenne");

    if(option === 0){
        regleStrict.style.display = 'flex';
        regleMoyenne.style.display = 'none';
    }else if(option === 1){
        regleMoyenne.style.display = 'flex';
        regleStrict.style.display = 'none';
    }
}

/** Fonction qui va réinitialiser les menus et remettre les valeurs par défaut.
 * On fait appel à cette fonction à chaque fois que l'on change/quitte le menu
 * @param {HTMLElement | null} menu - Menu à réinitialiser
 */
function nettoyerMenu(menu) {
    const listeRadioBoutons = menu.querySelectorAll('input[type="radio"]');
    listeRadioBoutons.forEach((radio) => {
        radio.checked = !((radio.id !== 'j2') &amp;&amp; (radio.id !== 'r1'));
    });

    let div = get('selection-nom-joueurs');
    for (let i = div.children.length - 1; i >= 0; i--) {
        if (div.children[i].type === 'text') {
            div.removeChild(div.children[i]);
        }
    }

    const saisieFichier = _('input[type="file"]');
    saisieFichier.value = '';
}

/** Fonction qui va afficher les entrées text pour saisir les noms des joueurs
 * @param {number} nb - Nombre de joueurs sélectionner
 */
function afficherJoueur(nb) {
    const defauts = ['ex : \"Seiya\"', 'ex : \"Shiryu\"', 'ex : \"Shun\"', 'ex : \"Hyoga\"'];
    let div = get('selection-nom-joueurs');
    const listeNomJoueurs = [];

    for(let saisie of div.children){
        if(saisie.type==="text")
            listeNomJoueurs.push(saisie.value);
    }

    while (div.firstChild) {
        div.removeChild(div.firstChild);
    }

    for (let i=0; i&lt;nb; i++) {
        let input = create('input');
        input.type = "text";
        input.name = "nomJoueurs";
        input.id = "jt"+(i+1);
        input.placeholder = defauts[i];
        div.appendChild(input);
    }

    let index = 0;
    for(let i = 0; i &lt; div.childElementCount; i++){
        if(div.childNodes[i].type === "text" &amp;&amp; index &lt; listeNomJoueurs.length){
            div.childNodes[i].value = listeNomJoueurs[index];
            index++;
        }
    }
}

/**Fonction qui va lancer le traitement des données afin de pouvoir répondre à la demande de l'utilisateur.
 * Récupère toutes les données et utilise ensuite la classe Adaptateur
 * @param {0 | 1} option - Type de partie à lancer (0 pour une nouvelle partie | 1 pour reprendre une partie)
 */
function validerFormulaire(option) {
    let monAdaptateur = new Adaptateur(option);  
}

/** Fonction qui sera appeler au chargement de la page
 * permet juste de nettoyer les menus avant le premier clique de l'utilisateur */
function fInit(){
    nettoyerMenu(get('0'));
    nettoyerMenu(get('1'));
}

if (typeof window == 'object') {
    window.onload = fInit;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Adaptateur.html">Adaptateur</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Modes">Modes</a></li><li><a href="global.html#_">_</a></li><li><a href="global.html#afficherJoueur">afficherJoueur</a></li><li><a href="global.html#afficherMenu">afficherMenu</a></li><li><a href="global.html#afficherRegleMode">afficherRegleMode</a></li><li><a href="global.html#afficherRegles">afficherRegles</a></li><li><a href="global.html#changeButton">changeButton</a></li><li><a href="global.html#chargerPartie">chargerPartie</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#endTask">endTask</a></li><li><a href="global.html#fInit">fInit</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getData">getData</a></li><li><a href="global.html#initialiserPartie">initialiserPartie</a></li><li><a href="global.html#listeTaches">listeTaches</a></li><li><a href="global.html#loadCartes">loadCartes</a></li><li><a href="global.html#masquerRegles">masquerRegles</a></li><li><a href="global.html#nettoyerMenu">nettoyerMenu</a></li><li><a href="global.html#nextTask">nextTask</a></li><li><a href="global.html#nextTurn">nextTurn</a></li><li><a href="global.html#printCarte">printCarte</a></li><li><a href="global.html#reloadCartes">reloadCartes</a></li><li><a href="global.html#saveData">saveData</a></li><li><a href="global.html#saveGame">saveGame</a></li><li><a href="global.html#validerChoix">validerChoix</a></li><li><a href="global.html#validerFormulaire">validerFormulaire</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Fri Dec 08 2023 16:11:52 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
